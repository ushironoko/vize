//! Test runner for Vue compiler - compares output with Vue's official compiler.
//!
//! This runner reads fixtures from tests/fixtures/ and expected outputs from
//! tests/expected/ (generated by bench/generate-expected.js using @vue/compiler-sfc).

use serde::Deserialize;
use std::path::Path;
use vize_atelier_core::{
    codegen::generate,
    options::{CodegenMode, CodegenOptions, ParserOptions, TransformOptions},
    parser::parse_with_options,
    transform::transform,
};
use vize_atelier_sfc::{compile_sfc, parse_sfc, SfcCompileOptions, SfcParseOptions};
use vize_atelier_vapor::{compile_vapor, VaporCompilerOptions};
use vize_carton::Allocator;

/// Test fixture file
#[derive(Debug, Deserialize)]
pub struct TestFixture {
    #[serde(default)]
    pub mode: CompilerMode,
    pub cases: Vec<TestCase>,
}

/// Compiler mode
#[derive(Debug, Default, Deserialize, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum CompilerMode {
    #[default]
    Vdom,
    Vapor,
    Sfc,
}

/// Single test case
#[derive(Debug, Deserialize)]
pub struct TestCase {
    pub name: String,
    pub input: String,
    #[serde(default)]
    pub options: TestOptions,
}

/// Test options
#[derive(Debug, Default, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TestOptions {
    #[serde(default)]
    pub mode: Option<CompilerMode>,
    #[serde(default)]
    pub prefix_identifiers: Option<bool>,
    #[serde(default)]
    pub hoist_static: Option<bool>,
    #[serde(default)]
    pub cache_handlers: Option<bool>,
    #[serde(default)]
    pub ssr: Option<bool>,
}

/// Expected test case from .snap file
#[derive(Debug)]
pub struct ExpectedCase {
    pub name: String,
    pub input: String,
    pub expected: String,
    pub has_errors: bool,
}

/// Parse .snap file format
/// New format:
/// ===
/// name: test name
/// options: default
/// --- INPUT ---
/// <div>{{ msg }}</div>
/// --- OUTPUT ---
/// compiled code
/// ===
pub fn parse_snap_file(content: &str) -> Vec<ExpectedCase> {
    let mut cases = Vec::new();

    // Split by "===" at start of line
    for block in content.split("\n===\n") {
        let block = block.trim_start_matches("===\n").trim();
        if block.is_empty() {
            continue;
        }

        // Parse header (before --- INPUT ---)
        let Some(input_marker_pos) = block.find("--- INPUT ---") else {
            continue;
        };

        let header = &block[..input_marker_pos];
        let after_input_marker = &block[input_marker_pos + "--- INPUT ---".len()..];

        // Parse INPUT section (between --- INPUT --- and --- OUTPUT ---)
        let Some(output_marker_pos) = after_input_marker.find("--- OUTPUT ---") else {
            continue;
        };

        let input = after_input_marker[..output_marker_pos].trim().to_string();
        let mut code = after_input_marker[output_marker_pos + "--- OUTPUT ---".len()..]
            .trim()
            .to_string();

        // Handle CSS section in SFC
        if let Some(idx) = code.find("--- CSS ---") {
            code = code[..idx].trim().to_string();
        }

        let mut name = String::new();
        let mut has_errors = false;

        for line in header.lines() {
            if let Some(idx) = line.find(':') {
                let key = line[..idx].trim();
                let value = line[idx + 1..].trim();

                match key {
                    "name" => name = value.to_string(),
                    "errors" => has_errors = true,
                    _ => {}
                }
            }
        }

        if !name.is_empty() && !input.is_empty() {
            cases.push(ExpectedCase {
                name,
                input,
                expected: code,
                has_errors,
            });
        }
    }

    cases
}

/// Load a test fixture from a TOML file
pub fn load_fixture(path: &Path) -> Result<TestFixture, toml::de::Error> {
    let content = std::fs::read_to_string(path).expect("Failed to read fixture file");
    toml::from_str(&content)
}

/// Load expected outputs from a .snap file
pub fn load_expected(path: &Path) -> Vec<ExpectedCase> {
    let content = std::fs::read_to_string(path).expect("Failed to read expected file");
    parse_snap_file(&content)
}

/// Compile a template with VDOM mode
pub fn compile_vdom(input: &str, options: &TestOptions) -> String {
    let allocator = Allocator::default();

    let parser_opts = ParserOptions {
        is_void_tag: vize_carton::is_void_tag,
        is_native_tag: Some(vize_carton::is_native_tag),
        is_pre_tag: |tag| tag == "pre",
        ..Default::default()
    };

    let (mut root, _errors) = parse_with_options(&allocator, input, parser_opts);

    let transform_opts = TransformOptions {
        prefix_identifiers: options.prefix_identifiers.unwrap_or(true),
        hoist_static: options.hoist_static.unwrap_or(false),
        cache_handlers: options.cache_handlers.unwrap_or(false),
        ssr: options.ssr.unwrap_or(false),
        ..Default::default()
    };
    transform(&allocator, &mut root, transform_opts);

    let codegen_opts = CodegenOptions {
        mode: CodegenMode::Module,
        ssr: options.ssr.unwrap_or(false),
        cache_handlers: options.cache_handlers.unwrap_or(false),
        ..Default::default()
    };
    let result = generate(&root, codegen_opts);

    // Combine preamble and code like Vue does
    let preamble = result.preamble.trim();
    if preamble.is_empty() {
        result.code.to_string()
    } else {
        format!("{}\n\n{}", preamble, result.code)
    }
}

/// Compile a template with Vapor mode
pub fn compile_vapor_template(input: &str, _options: &TestOptions) -> String {
    let allocator = Allocator::default();
    let vapor_opts = VaporCompilerOptions::default();
    let result = compile_vapor(&allocator, input, vapor_opts);
    result.code
}

/// Compile SFC
pub fn compile_sfc_template(input: &str, _options: &TestOptions) -> String {
    let parse_opts = SfcParseOptions::default();
    let descriptor = match parse_sfc(input, parse_opts) {
        Ok(d) => d,
        Err(_) => return String::new(),
    };

    // Use "test.vue" as the filename to match Vue's expected output
    let mut compile_opts = SfcCompileOptions::default();
    compile_opts.script.id = Some("test.vue".to_string());
    match compile_sfc(&descriptor, compile_opts) {
        Ok(result) => result.code,
        Err(_) => String::new(),
    }
}

/// Compile a template based on mode
pub fn compile(input: &str, mode: CompilerMode, options: &TestOptions) -> String {
    let effective_mode = options.mode.unwrap_or(mode);
    match effective_mode {
        CompilerMode::Vdom => compile_vdom(input, options),
        CompilerMode::Vapor => compile_vapor_template(input, options),
        CompilerMode::Sfc => compile_sfc_template(input, options),
    }
}

/// Normalize code for comparison (same logic as JS version)
pub fn normalize_code(code: &str) -> String {
    let mut lines: Vec<String> = code
        .replace("\r\n", "\n")
        .lines()
        .map(|line| line.trim_end().to_string())
        .collect();

    // Sort import helpers alphabetically
    for line in &mut lines {
        if line.starts_with("import {") && line.contains("} from \"vue\"") {
            if let Some(start) = line.find('{') {
                if let Some(end) = line.find('}') {
                    let helpers_str = &line[start + 1..end];
                    let mut helpers: Vec<&str> = helpers_str.split(',').map(|s| s.trim()).collect();
                    helpers.sort();
                    *line = format!("import {{ {} }} from \"vue\"", helpers.join(", "));
                }
            }
        }
    }

    // Remove excessive blank lines
    let result: Vec<&str> = lines.iter().map(|s| s.as_str()).collect();
    let mut output = Vec::new();
    let mut prev_blank = false;

    for line in result {
        let is_blank = line.is_empty();
        if is_blank && prev_blank {
            continue;
        }
        output.push(line);
        prev_blank = is_blank;
    }

    output.join("\n").trim().to_string()
}

/// Compare actual output with expected
pub fn compare_output(expected: &str, actual: &str) -> Result<(), String> {
    let norm_expected = normalize_code(expected);
    let norm_actual = normalize_code(actual);

    if norm_expected == norm_actual {
        return Ok(());
    }

    let exp_lines: Vec<&str> = norm_expected.lines().collect();
    let act_lines: Vec<&str> = norm_actual.lines().collect();

    for (i, (exp, act)) in exp_lines.iter().zip(act_lines.iter()).enumerate() {
        if exp != act {
            return Err(format!(
                "Mismatch at line {}:\n  expected: {}\n  actual:   {}",
                i + 1,
                exp,
                act
            ));
        }
    }

    if exp_lines.len() != act_lines.len() {
        return Err(format!(
            "Line count mismatch: expected {}, got {}",
            exp_lines.len(),
            act_lines.len()
        ));
    }

    Err("Unknown mismatch".to_string())
}

/// Test result
#[derive(Debug)]
pub struct TestResult {
    pub name: String,
    pub passed: bool,
    pub error: Option<String>,
}

/// Run tests for a fixture file
pub fn run_fixture_tests(fixture_path: &Path, expected_path: &Path) -> Vec<TestResult> {
    let mut results = Vec::new();

    if !fixture_path.exists() || !expected_path.exists() {
        return results;
    }

    let fixture = match load_fixture(fixture_path) {
        Ok(f) => f,
        Err(e) => {
            results.push(TestResult {
                name: fixture_path.display().to_string(),
                passed: false,
                error: Some(format!("Failed to parse fixture: {}", e)),
            });
            return results;
        }
    };

    let expected_cases = load_expected(expected_path);

    for case in &fixture.cases {
        // Find matching expected case
        let expected = expected_cases.iter().find(|e| e.name == case.name);

        let result = match expected {
            None => TestResult {
                name: case.name.clone(),
                passed: false,
                error: Some("No expected output found".to_string()),
            },
            Some(exp) if exp.has_errors => TestResult {
                name: case.name.clone(),
                passed: true, // Skip error cases
                error: None,
            },
            Some(exp) => {
                let actual = compile(&case.input, fixture.mode, &case.options);
                match compare_output(&exp.expected, &actual) {
                    Ok(()) => TestResult {
                        name: case.name.clone(),
                        passed: true,
                        error: None,
                    },
                    Err(e) => TestResult {
                        name: case.name.clone(),
                        passed: false,
                        error: Some(e),
                    },
                }
            }
        };

        results.push(result);
    }

    results
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    fn fixtures_path() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("fixtures")
    }

    fn expected_path() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("expected")
    }

    macro_rules! test_fixture {
        ($name:ident, $path:expr) => {
            #[test]
            #[ignore = "Use `mise run coverage` instead"]
            fn $name() {
                let fixture = fixtures_path().join(concat!($path, ".toml"));
                let expected = expected_path().join(concat!($path, ".snap"));

                let results = run_fixture_tests(&fixture, &expected);

                let mut failures = Vec::new();
                for result in &results {
                    if !result.passed {
                        failures.push(format!(
                            "  {} - {}",
                            result.name,
                            result.error.as_deref().unwrap_or("unknown error")
                        ));
                    }
                }

                if !failures.is_empty() {
                    let passed = results.iter().filter(|r| r.passed).count();
                    let total = results.len();
                    panic!(
                        "\n{} tests failed ({}/{} passed):\n{}",
                        failures.len(),
                        passed,
                        total,
                        failures.join("\n")
                    );
                }
            }
        };
    }

    // VDom tests
    test_fixture!(vdom_element, "vdom/element");
    test_fixture!(vdom_component, "vdom/component");
    test_fixture!(vdom_directives, "vdom/directives");
    test_fixture!(vdom_hoisting, "vdom/hoisting");
    test_fixture!(vdom_patch_flags, "vdom/patch-flags");
    test_fixture!(vdom_v_if, "vdom/v-if");
    test_fixture!(vdom_v_for, "vdom/v-for");
    test_fixture!(vdom_v_bind, "vdom/v-bind");
    test_fixture!(vdom_v_on, "vdom/v-on");
    test_fixture!(vdom_v_model, "vdom/v-model");
    test_fixture!(vdom_v_slot, "vdom/v-slot");
    test_fixture!(vdom_v_show, "vdom/v-show");
    test_fixture!(vdom_v_once, "vdom/v-once");

    // Vapor tests
    test_fixture!(vapor_element, "vapor/element");
    test_fixture!(vapor_component, "vapor/component");
    test_fixture!(vapor_v_if, "vapor/v-if");
    test_fixture!(vapor_v_for, "vapor/v-for");
    test_fixture!(vapor_v_bind, "vapor/v-bind");
    test_fixture!(vapor_v_on, "vapor/v-on");
    test_fixture!(vapor_v_model, "vapor/v-model");
    test_fixture!(vapor_v_slot, "vapor/v-slot");
    test_fixture!(vapor_v_show, "vapor/v-show");
}
