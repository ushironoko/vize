//! Test runner for Vue compiler - compares output with Vue's official compiler.
//!
//! This runner reads fixtures from tests/fixtures/ and expected outputs from
//! tests/expected/ (generated by bench/generate-expected.js using @vue/compiler-sfc).

use serde::Deserialize;
use std::path::Path;
use vize_atelier_core::{
    codegen::generate,
    options::{CodegenMode, CodegenOptions, ParserOptions, TransformOptions},
    parser::parse_with_options,
    transform::transform,
};
use vize_atelier_sfc::{compile_sfc, parse_sfc, SfcCompileOptions, SfcParseOptions};
use vize_atelier_vapor::{compile_vapor, VaporCompilerOptions};
use vize_carton::Allocator;

/// Test fixture file
#[derive(Debug, Deserialize)]
pub struct TestFixture {
    #[serde(default)]
    pub mode: CompilerMode,
    pub cases: Vec<TestCase>,
}

/// Compiler mode
#[derive(Debug, Default, Deserialize, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum CompilerMode {
    #[default]
    Vdom,
    Vapor,
    Sfc,
}

/// Single test case
#[derive(Debug, Deserialize)]
pub struct TestCase {
    pub name: String,
    pub input: String,
    #[serde(default)]
    pub options: TestOptions,
}

/// Test options
#[derive(Debug, Default, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TestOptions {
    #[serde(default)]
    pub mode: Option<CompilerMode>,
    #[serde(default)]
    pub prefix_identifiers: Option<bool>,
    #[serde(default)]
    pub hoist_static: Option<bool>,
    #[serde(default)]
    pub cache_handlers: Option<bool>,
    #[serde(default)]
    pub ssr: Option<bool>,
}

/// Expected test case from .snap file
#[derive(Debug)]
pub struct ExpectedCase {
    pub name: String,
    pub input: String,
    pub expected: String,
    pub has_errors: bool,
}

/// Parse .snap file format
/// New format:
/// ===
/// name: test name
/// options: default
/// --- INPUT ---
/// <div>{{ msg }}</div>
/// --- OUTPUT ---
/// compiled code
/// ===
pub fn parse_snap_file(content: &str) -> Vec<ExpectedCase> {
    let mut cases = Vec::new();

    // Split by "===" at start of line
    for block in content.split("\n===\n") {
        let block = block.trim_start_matches("===\n").trim();
        if block.is_empty() {
            continue;
        }

        // Parse header (before --- INPUT ---)
        let Some(input_marker_pos) = block.find("--- INPUT ---") else {
            continue;
        };

        let header = &block[..input_marker_pos];
        let after_input_marker = &block[input_marker_pos + "--- INPUT ---".len()..];

        // Parse INPUT section (between --- INPUT --- and --- OUTPUT ---)
        let Some(output_marker_pos) = after_input_marker.find("--- OUTPUT ---") else {
            continue;
        };

        let input = after_input_marker[..output_marker_pos].trim().to_string();
        let mut code = after_input_marker[output_marker_pos + "--- OUTPUT ---".len()..]
            .trim()
            .to_string();

        // Handle CSS section in SFC
        if let Some(idx) = code.find("--- CSS ---") {
            code = code[..idx].trim().to_string();
        }

        let mut name = String::new();
        let mut has_errors = false;

        for line in header.lines() {
            if let Some(idx) = line.find(':') {
                let key = line[..idx].trim();
                let value = line[idx + 1..].trim();

                match key {
                    "name" => name = value.to_string(),
                    "errors" => has_errors = true,
                    _ => {}
                }
            }
        }

        if !name.is_empty() && !input.is_empty() {
            cases.push(ExpectedCase {
                name,
                input,
                expected: code,
                has_errors,
            });
        }
    }

    cases
}

/// Load a test fixture from a TOML file
pub fn load_fixture(path: &Path) -> Result<TestFixture, toml::de::Error> {
    let content = std::fs::read_to_string(path).expect("Failed to read fixture file");
    toml::from_str(&content)
}

/// Load expected outputs from a .snap file
pub fn load_expected(path: &Path) -> Vec<ExpectedCase> {
    let content = std::fs::read_to_string(path).expect("Failed to read expected file");
    parse_snap_file(&content)
}

/// Compile a template with VDOM mode
pub fn compile_vdom(input: &str, options: &TestOptions) -> String {
    let allocator = Allocator::default();

    let parser_opts = ParserOptions {
        is_void_tag: vize_carton::is_void_tag,
        is_native_tag: Some(vize_carton::is_native_tag),
        is_pre_tag: |tag| tag == "pre",
        ..Default::default()
    };

    let (mut root, _errors) = parse_with_options(&allocator, input, parser_opts);

    let transform_opts = TransformOptions {
        prefix_identifiers: options.prefix_identifiers.unwrap_or(true),
        hoist_static: options.hoist_static.unwrap_or(false),
        cache_handlers: options.cache_handlers.unwrap_or(false),
        ssr: options.ssr.unwrap_or(false),
        ..Default::default()
    };
    transform(&allocator, &mut root, transform_opts);

    let codegen_opts = CodegenOptions {
        mode: CodegenMode::Module,
        ssr: options.ssr.unwrap_or(false),
        cache_handlers: options.cache_handlers.unwrap_or(false),
        ..Default::default()
    };
    let result = generate(&root, codegen_opts);

    // Combine preamble and code like Vue does
    let preamble = result.preamble.trim();
    if preamble.is_empty() {
        result.code.to_string()
    } else {
        format!("{}\n\n{}", preamble, result.code)
    }
}

/// Compile a template with Vapor mode
pub fn compile_vapor_template(input: &str, _options: &TestOptions) -> String {
    let allocator = Allocator::default();
    let vapor_opts = VaporCompilerOptions::default();
    let result = compile_vapor(&allocator, input, vapor_opts);
    result.code
}

/// Compile SFC
pub fn compile_sfc_template(input: &str, _options: &TestOptions) -> String {
    let parse_opts = SfcParseOptions::default();
    let descriptor = match parse_sfc(input, parse_opts) {
        Ok(d) => d,
        Err(_) => return String::new(),
    };

    // Use "test.vue" as the filename to match Vue's expected output
    let mut compile_opts = SfcCompileOptions::default();
    compile_opts.script.id = Some("test.vue".to_string());
    match compile_sfc(&descriptor, compile_opts) {
        Ok(result) => result.code,
        Err(_) => String::new(),
    }
}

/// Compile a template based on mode
pub fn compile(input: &str, mode: CompilerMode, options: &TestOptions) -> String {
    let effective_mode = options.mode.unwrap_or(mode);
    match effective_mode {
        CompilerMode::Vdom => compile_vdom(input, options),
        CompilerMode::Vapor => compile_vapor_template(input, options),
        CompilerMode::Sfc => compile_sfc_template(input, options),
    }
}

/// Normalize code for comparison (same logic as JS version)
pub fn normalize_code(code: &str) -> String {
    let mut lines: Vec<String> = code
        .replace("\r\n", "\n")
        .lines()
        .map(|line| {
            // Trim leading/trailing whitespace (normalize indentation)
            line.trim().to_string()
        })
        .collect();

    // Sort import helpers alphabetically and normalize quotes
    for line in &mut lines {
        // Normalize import lines from 'vue' or "vue"
        let is_vue_import = (line.starts_with("import {") || line.starts_with("import {"))
            && (line.contains("} from \"vue\"") || line.contains("} from 'vue'"));
        if is_vue_import {
            if let Some(start) = line.find('{') {
                if let Some(end) = line.find('}') {
                    let helpers_str = &line[start + 1..end];
                    let mut helpers: Vec<&str> = helpers_str.split(',').map(|s| s.trim()).collect();
                    helpers.sort();
                    *line = format!("import {{ {} }} from \"vue\"", helpers.join(", "));
                }
            }
        }
    }

    // Normalize each line: remove trailing semicolons, normalize quotes
    for line in &mut lines {
        // Remove trailing semicolons
        while line.ends_with(';') {
            line.pop();
        }
        // Normalize single quotes to double quotes for comparison
        *line = normalize_quotes(line);
    }

    // Remove all blank lines for comparison
    let output: Vec<&str> = lines
        .iter()
        .map(|s| s.as_str())
        .filter(|s| !s.is_empty())
        .collect();

    // Join all lines into single string, then collapse multiline expressions
    let joined = output.join("\n").trim().to_string();

    // Collapse multiline function calls into single lines:
    // This handles cases where one compiler puts arguments on separate lines
    collapse_multiline(&joined)
}

/// Collapse multiline expressions by joining lines where brackets are unbalanced.
fn collapse_multiline(code: &str) -> String {
    let lines: Vec<&str> = code.lines().collect();
    let mut result: Vec<String> = Vec::new();

    for line in &lines {
        let trimmed = line.trim();

        // Remove block comments like /* TEXT */ or /* KEYED_FRAGMENT */
        let cleaned = remove_block_comments(trimmed);
        let cleaned = cleaned.trim();
        if cleaned.is_empty() {
            continue;
        }

        // If the previous line has unbalanced brackets, join this line to it
        let should_join = if let Some(last) = result.last() {
            !brackets_balanced(last)
        } else {
            false
        };

        if should_join {
            if let Some(last) = result.last_mut() {
                last.push(' ');
                last.push_str(cleaned);
            }
        } else {
            result.push(cleaned.to_string());
        }
    }

    // Normalize parentheses in return statements: `return (expr)` -> `return expr`
    for line in &mut result {
        if line.starts_with("return (") && line.ends_with(')') {
            let inner = &line[7..]; // "return " is 7 chars
            if is_outer_parens_balanced(inner) {
                *line = format!("return {}", &inner[1..inner.len() - 1]);
            }
        }
    }

    // Normalize multiple spaces to single space
    for line in &mut result {
        while line.contains("  ") {
            *line = line.replace("  ", " ");
        }
    }

    // Normalize spaces around parentheses: "( " -> "(", " )" -> ")"
    // Also normalize "[ " -> "[", " ]" -> "]"
    for line in &mut result {
        *line = normalize_bracket_spaces(line);
    }

    result.join("\n")
}

/// Check if parens and square brackets are balanced in a line.
/// Only checks ( ) and [ ], NOT { } â€” we want to preserve statement structure.
fn brackets_balanced(line: &str) -> bool {
    let mut paren = 0i32;
    let mut square = 0i32;
    let mut in_string = false;
    let mut string_char = ' ';
    let chars: Vec<char> = line.chars().collect();
    let mut i = 0;
    while i < chars.len() {
        let ch = chars[i];
        if in_string {
            if ch == '\\' && i + 1 < chars.len() {
                i += 2;
                continue;
            }
            if ch == string_char {
                in_string = false;
            }
        } else {
            match ch {
                '"' | '\'' | '`' => {
                    in_string = true;
                    string_char = ch;
                }
                '(' => paren += 1,
                ')' => paren -= 1,
                '[' => square += 1,
                ']' => square -= 1,
                _ => {}
            }
        }
        i += 1;
    }
    paren == 0 && square == 0
}

/// Remove block comments like /* TEXT */ from a line
fn remove_block_comments(line: &str) -> String {
    let mut result = String::new();
    let mut in_comment = false;
    let chars: Vec<char> = line.chars().collect();
    let mut i = 0;
    while i < chars.len() {
        if !in_comment && i + 1 < chars.len() && chars[i] == '/' && chars[i + 1] == '*' {
            in_comment = true;
            i += 2;
        } else if in_comment && i + 1 < chars.len() && chars[i] == '*' && chars[i + 1] == '/' {
            in_comment = false;
            i += 2;
        } else if !in_comment {
            result.push(chars[i]);
            i += 1;
        } else {
            i += 1;
        }
    }
    result
}

/// Check if the outer parentheses of a string are balanced
fn is_outer_parens_balanced(s: &str) -> bool {
    if !s.starts_with('(') || !s.ends_with(')') {
        return false;
    }
    let mut depth = 0;
    for (i, ch) in s.chars().enumerate() {
        match ch {
            '(' => depth += 1,
            ')' => {
                depth -= 1;
                if depth == 0 && i < s.len() - 1 {
                    return false; // Closed before the end
                }
            }
            _ => {}
        }
    }
    depth == 0
}

/// Normalize spaces around brackets: "( " -> "(", " )" -> ")", etc.
/// Be careful not to modify content inside strings.
fn normalize_bracket_spaces(line: &str) -> String {
    // Simple approach: replace "( " with "(" and " )" with ")" etc.
    // This is safe because spaces immediately inside parens/brackets are never significant in JS
    let mut result = line.to_string();
    // Iteratively clean up bracket spaces
    loop {
        let prev = result.clone();
        result = result.replace("( ", "(");
        result = result.replace(" )", ")");
        result = result.replace("[ ", "[");
        result = result.replace(" ]", "]");
        if result == prev {
            break;
        }
    }
    result
}

/// Normalize quotes: convert single quotes to double quotes,
/// being careful about strings that contain the other quote type
fn normalize_quotes(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let chars: Vec<char> = s.chars().collect();
    let mut i = 0;
    while i < chars.len() {
        if chars[i] == '\'' {
            // Convert single-quoted string to double-quoted
            result.push('"');
            i += 1;
            while i < chars.len() && chars[i] != '\'' {
                if chars[i] == '\\' && i + 1 < chars.len() {
                    result.push(chars[i]);
                    result.push(chars[i + 1]);
                    i += 2;
                } else {
                    result.push(chars[i]);
                    i += 1;
                }
            }
            if i < chars.len() {
                result.push('"');
                i += 1;
            }
        } else if chars[i] == '"' {
            // Keep double-quoted strings as-is
            result.push(chars[i]);
            i += 1;
            while i < chars.len() && chars[i] != '"' {
                if chars[i] == '\\' && i + 1 < chars.len() {
                    result.push(chars[i]);
                    result.push(chars[i + 1]);
                    i += 2;
                } else {
                    result.push(chars[i]);
                    i += 1;
                }
            }
            if i < chars.len() {
                result.push(chars[i]);
                i += 1;
            }
        } else {
            result.push(chars[i]);
            i += 1;
        }
    }
    result
}

/// Compare actual output with expected
pub fn compare_output(expected: &str, actual: &str) -> Result<(), String> {
    let norm_expected = normalize_code(expected);
    let norm_actual = normalize_code(actual);

    if norm_expected == norm_actual {
        return Ok(());
    }

    let exp_lines: Vec<&str> = norm_expected.lines().collect();
    let act_lines: Vec<&str> = norm_actual.lines().collect();

    for (i, (exp, act)) in exp_lines.iter().zip(act_lines.iter()).enumerate() {
        if exp != act {
            return Err(format!(
                "Mismatch at line {}:\n  expected: {}\n  actual:   {}",
                i + 1,
                exp,
                act
            ));
        }
    }

    if exp_lines.len() != act_lines.len() {
        return Err(format!(
            "Line count mismatch: expected {}, got {}",
            exp_lines.len(),
            act_lines.len()
        ));
    }

    Err("Unknown mismatch".to_string())
}

/// Test result
#[derive(Debug)]
pub struct TestResult {
    pub name: String,
    pub passed: bool,
    pub error: Option<String>,
}

/// Run tests for a fixture file
pub fn run_fixture_tests(fixture_path: &Path, expected_path: &Path) -> Vec<TestResult> {
    let mut results = Vec::new();

    if !fixture_path.exists() || !expected_path.exists() {
        return results;
    }

    let fixture = match load_fixture(fixture_path) {
        Ok(f) => f,
        Err(e) => {
            results.push(TestResult {
                name: fixture_path.display().to_string(),
                passed: false,
                error: Some(format!("Failed to parse fixture: {}", e)),
            });
            return results;
        }
    };

    let expected_cases = load_expected(expected_path);

    for case in &fixture.cases {
        // Find matching expected case
        let expected = expected_cases.iter().find(|e| e.name == case.name);

        let result = match expected {
            None => TestResult {
                name: case.name.clone(),
                passed: false,
                error: Some("No expected output found".to_string()),
            },
            Some(exp) if exp.has_errors => TestResult {
                name: case.name.clone(),
                passed: true, // Skip error cases
                error: None,
            },
            Some(exp) => {
                let actual = compile(&case.input, fixture.mode, &case.options);
                match compare_output(&exp.expected, &actual) {
                    Ok(()) => TestResult {
                        name: case.name.clone(),
                        passed: true,
                        error: None,
                    },
                    Err(e) => TestResult {
                        name: case.name.clone(),
                        passed: false,
                        error: Some(e),
                    },
                }
            }
        };

        results.push(result);
    }

    results
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    fn fixtures_path() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("fixtures")
    }

    fn expected_path() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("expected")
    }

    macro_rules! test_fixture {
        ($name:ident, $path:expr) => {
            #[test]
            #[ignore = "Use `mise run coverage` instead"]
            fn $name() {
                let fixture = fixtures_path().join(concat!($path, ".toml"));
                let expected = expected_path().join(concat!($path, ".snap"));

                let results = run_fixture_tests(&fixture, &expected);

                let mut failures = Vec::new();
                for result in &results {
                    if !result.passed {
                        failures.push(format!(
                            "  {} - {}",
                            result.name,
                            result.error.as_deref().unwrap_or("unknown error")
                        ));
                    }
                }

                if !failures.is_empty() {
                    let passed = results.iter().filter(|r| r.passed).count();
                    let total = results.len();
                    panic!(
                        "\n{} tests failed ({}/{} passed):\n{}",
                        failures.len(),
                        passed,
                        total,
                        failures.join("\n")
                    );
                }
            }
        };
    }

    // VDom tests
    test_fixture!(vdom_element, "vdom/element");
    test_fixture!(vdom_component, "vdom/component");
    test_fixture!(vdom_directives, "vdom/directives");
    test_fixture!(vdom_hoisting, "vdom/hoisting");
    test_fixture!(vdom_patch_flags, "vdom/patch-flags");
    test_fixture!(vdom_v_if, "vdom/v-if");
    test_fixture!(vdom_v_for, "vdom/v-for");
    test_fixture!(vdom_v_bind, "vdom/v-bind");
    test_fixture!(vdom_v_on, "vdom/v-on");
    test_fixture!(vdom_v_model, "vdom/v-model");
    test_fixture!(vdom_v_slot, "vdom/v-slot");
    test_fixture!(vdom_v_show, "vdom/v-show");
    test_fixture!(vdom_v_once, "vdom/v-once");

    // Vapor tests
    test_fixture!(vapor_element, "vapor/element");
    test_fixture!(vapor_component, "vapor/component");
    test_fixture!(vapor_v_if, "vapor/v-if");
    test_fixture!(vapor_v_for, "vapor/v-for");
    test_fixture!(vapor_v_bind, "vapor/v-bind");
    test_fixture!(vapor_v_on, "vapor/v-on");
    test_fixture!(vapor_v_model, "vapor/v-model");
    test_fixture!(vapor_v_slot, "vapor/v-slot");
    test_fixture!(vapor_v_show, "vapor/v-show");
}
