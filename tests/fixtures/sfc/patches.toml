# SFC tests: Patch regression tests
# Tests for bug fixes and improvements discovered during real-world usage

mode = "sfc"

# =============================================================================
# ES6 Shorthand expansion (expression.rs)
# Issue: { foo } was not prefixed with $setup.
# Fix: Expand shorthand to { foo: $setup.foo }
# =============================================================================

[[cases]]
name = "ES6 shorthand in event handler object"
input = """
<script setup>
import { ref } from 'vue'
const foo = ref('value')
const bar = ref(123)
</script>

<template>
  <div @click="handleEvent({ foo, bar })">Test</div>
</template>
"""

[[cases]]
name = "ES6 shorthand in computed style"
input = """
<script setup>
import { ref } from 'vue'
const width = ref(100)
const height = ref(50)
</script>

<template>
  <div :style="{ width, height }">Styled</div>
</template>
"""

[[cases]]
name = "ES6 shorthand in v-bind object"
input = """
<script setup>
import { ref } from 'vue'
const disabled = ref(false)
const type = ref('button')
</script>

<template>
  <button v-bind="{ disabled, type }">Click</button>
</template>
"""

[[cases]]
name = "ES6 shorthand mixed with regular properties"
input = """
<script setup>
import { ref } from 'vue'
const name = ref('test')
</script>

<template>
  <Component :options="{ name, extra: 'value' }" />
</template>
"""

# =============================================================================
# SetupLet assignment with .value (expression.rs)
# Issue: let-declared reactive variables didn't get .value in assignments
# Fix: Add .value suffix for SetupLet/SetupMaybeRef in assignment LHS
# =============================================================================

[[cases]]
name = "SetupLet assignment in click handler"
input = """
<script setup>
let count = $ref(0)
</script>

<template>
  <button @click="count = count + 1">{{ count }}</button>
</template>
"""

[[cases]]
name = "let variable increment in handler"
input = """
<script setup>
let value = $ref(10)
</script>

<template>
  <button @click="value++">{{ value }}</button>
</template>
"""

# =============================================================================
# v-slot hyphenated names (slots.rs)
# Issue: slot names like "item-header" caused syntax errors
# Fix: Quote slot names that are not valid JS identifiers
# =============================================================================

[[cases]]
name = "v-slot with hyphenated name"
input = """
<script setup>
import DataTable from './DataTable.vue'
</script>

<template>
  <DataTable>
    <template #item-header="{ item }">
      <span>{{ item.title }}</span>
    </template>
  </DataTable>
</template>
"""

[[cases]]
name = "v-slot with multiple hyphenated names"
input = """
<script setup>
import Card from './Card.vue'
</script>

<template>
  <Card>
    <template #card-header>Header</template>
    <template #card-body>Body</template>
    <template #card-footer>Footer</template>
  </Card>
</template>
"""

[[cases]]
name = "v-slot mixed hyphenated and regular names"
input = """
<script setup>
import Layout from './Layout.vue'
</script>

<template>
  <Layout>
    <template #header>Regular</template>
    <template #main-content>Hyphenated</template>
    <template #footer>Regular Again</template>
  </Layout>
</template>
"""

# =============================================================================
# v-if duplicate event handlers (v_if.rs)
# Issue: v-model transform generated duplicate event handlers
# Fix: Use HashSet to filter duplicate events
# =============================================================================

[[cases]]
name = "v-if with v-model on input"
input = """
<script setup>
import { ref } from 'vue'
const show = ref(true)
const text = ref('')
</script>

<template>
  <input v-if="show" v-model="text" />
</template>
"""

[[cases]]
name = "v-if with v-model on component"
input = """
<script setup>
import { ref } from 'vue'
import MyInput from './MyInput.vue'
const visible = ref(true)
const value = ref('')
</script>

<template>
  <MyInput v-if="visible" v-model="value" />
</template>
"""

# =============================================================================
# v-if component props (v_if.rs)
# Issue: Extra brace emitted in component branch output for v-if
# Fix: Ensure component branch closes with `))` instead of `}))`
# =============================================================================

[[cases]]
name = "v-if with component props"
input = """
<script setup>
import PatinaPlayground from './PatinaPlayground.vue'
const show = true
const compiler = {}
</script>

<template>
  <template v-if="show">
    <PatinaPlayground :compiler="compiler" />
  </template>
</template>
"""

# =============================================================================
# v-if with v-bind object spread (v_if.rs)
# Issue: v-bind="obj" wasn't handled correctly in v-if branches
# Fix: Use _mergeProps for v-bind object spread
# =============================================================================

[[cases]]
name = "v-if with v-bind object spread"
input = """
<script setup>
import { ref, computed } from 'vue'
import Button from './Button.vue'
const isActive = ref(true)
const buttonProps = computed(() => ({ disabled: false, type: 'primary' }))
</script>

<template>
  <Button v-if="isActive" v-bind="buttonProps" @click="handleClick">
    Click me
  </Button>
</template>
"""

[[cases]]
name = "v-else-if with v-bind object spread"
input = """
<script setup>
import { ref } from 'vue'
import Icon from './Icon.vue'
const mode = ref('edit')
const iconProps = { size: 24, color: 'blue' }
</script>

<template>
  <Icon v-if="mode === 'view'" name="eye" />
  <Icon v-else-if="mode === 'edit'" v-bind="iconProps" name="pencil" />
  <Icon v-else name="default" />
</template>
"""

# =============================================================================
# v-for custom directives (v_for.rs)
# Issue: Custom directives like v-click-outside caused errors
# Fix: Skip custom directives in props generation
# =============================================================================

[[cases]]
name = "v-for with v-click-outside"
input = """
<script setup>
import { ref } from 'vue'
const items = ref([{ id: 1, name: 'Item 1' }])
function closeItem(id) {
  console.log('close', id)
}
</script>

<template>
  <div v-for="item in items" :key="item.id" v-click-outside="() => closeItem(item.id)">
    {{ item.name }}
  </div>
</template>
"""

[[cases]]
name = "v-for with custom directive on element"
input = """
<script setup>
const list = [1, 2, 3]
</script>

<template>
  <span v-for="n in list" :key="n" v-focus>{{ n }}</span>
</template>
"""

# =============================================================================
# Props destructure with type-based defineProps (context.rs, function_mode.rs)
# Issue: _mergeDefaults first arg was empty for type-based props
# Fix: Register define_props macro and generate runtime props from type_args
# =============================================================================

[[cases]]
name = "props destructure with type-based defineProps and defaults"
input = """
<script setup lang="ts">
const { color = "primary", size = "medium" } = defineProps<{
  color?: "primary" | "secondary";
  size?: "small" | "medium" | "large";
}>();
</script>

<template>
  <div :class="[color, size]">Styled</div>
</template>
"""

[[cases]]
name = "complex type-based props destructure with defaults"
input = """
<script setup lang="ts">
const {
  title,
  count = 0,
  disabled = false,
  items = () => []
} = defineProps<{
  title: string;
  count?: number;
  disabled?: boolean;
  items?: string[];
}>();
</script>

<template>
  <div :class="{ disabled }">
    <h1>{{ title }}</h1>
    <span>{{ count }}</span>
    <ul>
      <li v-for="item in items" :key="item">{{ item }}</li>
    </ul>
  </div>
</template>
"""

# =============================================================================
# Duplicate import filtering (function_mode.rs)
# Issue: Duplicate imports caused OXC semantic errors
# Fix: Use HashSet to filter duplicate imports
# =============================================================================

[[cases]]
name = "duplicate imports should be filtered"
input = """
<script setup lang="ts">
import { ref } from 'vue'
import { ref } from 'vue'
import { computed } from 'vue'
const count = ref(0)
const double = computed(() => count.value * 2)
</script>

<template>
  <div>{{ count }} {{ double }}</div>
</template>
"""

[[cases]]
name = "duplicate named imports should be filtered"
input = """
<script setup lang="ts">
import { cloneDeep } from 'lodash-es'
import { cloneDeep } from 'lodash-es'
import { merge } from 'lodash-es'
const data = cloneDeep({ value: 1 })
</script>

<template>
  <div>{{ data.value }}</div>
</template>
"""

# =============================================================================
# Async setup detection (function_mode.rs)
# Issue: Top-level await didn't generate async setup
# Fix: Detect await keyword and generate async setup()
# =============================================================================

[[cases]]
name = "top-level await generates async setup"
input = """
<script setup>
const response = await fetch('/api/data')
const data = await response.json()
</script>

<template>
  <div>{{ data }}</div>
</template>
"""

[[cases]]
name = "await in string literal should not trigger async"
input = """
<script setup>
const message = "please await for response"
const code = 'await is a keyword'
</script>

<template>
  <div>{{ message }}</div>
</template>
"""

# =============================================================================
# JavaScript reserved words in shorthand (function_mode.rs)
# Issue: { default } caused syntax error
# Fix: Exclude reserved words from shorthand expansion
# =============================================================================

[[cases]]
name = "default as prop name should not use shorthand"
input = """
<script setup>
import DefaultComponent from './Default.vue'
</script>

<template>
  <DefaultComponent />
</template>
"""

# =============================================================================
# Type comparison expression detection (function_mode.rs)
# Issue: `type === 'value'` was incorrectly detected as type alias
# Fix: Check for comparison operators after 'type' keyword
# =============================================================================

[[cases]]
name = "type comparison should not be stripped"
input = """
<script setup>
const props = defineProps(['type'])
const isButton = props.type === 'button'
const isLink = props.type !== 'link'
</script>

<template>
  <button v-if="isButton">Button</button>
  <a v-else-if="!isLink" href="#">Link</a>
</template>
"""

[[cases]]
name = "type keyword in conditional"
input = """
<script setup lang="ts">
interface Item {
  type: string;
  value: number;
}
const props = defineProps<{ item: Item }>()
</script>

<template>
  <div v-if="item.type === 'special'">{{ item.value }}</div>
</template>
"""

# =============================================================================
# Static string escaping (codegen.rs)
# Issue: Newlines and quotes in static strings weren't escaped
# Fix: Use escape_js_string() for static content
# =============================================================================

[[cases]]
name = "static string with newline"
input = """
<script setup>
const multiline = `Line 1
Line 2
Line 3`
</script>

<template>
  <pre>{{ multiline }}</pre>
</template>
"""

[[cases]]
name = "attribute with special characters"
input = """
<script setup>
</script>

<template>
  <div title="Hello &quot;World&quot;">Content</div>
</template>
"""

# =============================================================================
# v-model handler source (transform/element.rs)
# Issue: v-model handler used transformed content with _unref()
# Fix: Use original source (loc.source) for handler
# =============================================================================

[[cases]]
name = "v-model on native input with ref"
input = """
<script setup>
import { ref } from 'vue'
const inputValue = ref('')
</script>

<template>
  <input v-model="inputValue" />
</template>
"""

[[cases]]
name = "v-model on select with ref"
input = """
<script setup>
import { ref } from 'vue'
const selected = ref('option1')
</script>

<template>
  <select v-model="selected">
    <option value="option1">Option 1</option>
    <option value="option2">Option 2</option>
  </select>
</template>
"""

# =============================================================================
# Non-script-setup SFC handling (vite-plugin utils.ts)
# Issue: _sfc_main was duplicated for non-script-setup components
# Fix: Check if _sfc_main is already defined before adding
# =============================================================================

[[cases]]
name = "non-script-setup component with export default"
input = """
<script>
export default {
  name: 'MyComponent',
  props: {
    msg: String
  },
  data() {
    return {
      count: 0
    }
  }
}
</script>

<template>
  <div>{{ msg }} - {{ count }}</div>
</template>
"""

[[cases]]
name = "script with setup function"
input = """
<script>
import { ref } from 'vue'

export default {
  name: 'SetupFunctionComponent',
  setup() {
    const count = ref(0)
    return { count }
  }
}
</script>

<template>
  <div>{{ count }}</div>
</template>
"""

# =============================================================================
# TypeScript generic stripping (transform_expression.rs, typescript.rs)
# Issue: Generics like useStore<RootState>() weren't stripped
# Fix: Improve TypeScript detection and use OXC transformer
# =============================================================================

[[cases]]
name = "generic function call should be stripped"
input = """
<script setup lang="ts">
import { useStore } from 'vuex'

interface RootState {
  count: number
}

const store = useStore<RootState>()
</script>

<template>
  <div>{{ store.state.count }}</div>
</template>
"""

[[cases]]
name = "ref with generic type should be stripped"
input = """
<script setup lang="ts">
import { ref } from 'vue'

interface User {
  name: string
  age: number
}

const user = ref<User | null>(null)
const users = ref<User[]>([])
</script>

<template>
  <div v-if="user">{{ user.name }}</div>
</template>
"""

# =============================================================================
# Arrow function with type annotations (transform_expression.rs)
# Issue: Arrow function params with types weren't stripped correctly
# Fix: Detect type annotations in arrow function parameters
# =============================================================================

[[cases]]
name = "arrow function with typed parameters in template"
input = """
<script setup lang="ts">
import { ref } from 'vue'
const items = ref([1, 2, 3])
</script>

<template>
  <div>
    {{ items.filter((x: number) => x > 1) }}
  </div>
</template>
"""

[[cases]]
name = "callback with typed parameters"
input = """
<script setup lang="ts">
interface Item {
  id: number
  name: string
}
const items: Item[] = []
</script>

<template>
  <div>
    {{ items.map((item: Item) => item.name).join(', ') }}
  </div>
</template>
"""

# =============================================================================
# Multiline arrow function (transform_expression.rs)
# Issue: Multiline arrow functions were truncated at first semicolon
# Fix: Use rfind(';') instead of find(';')
# =============================================================================

[[cases]]
name = "multiline arrow function in event handler"
input = """
<script setup>
import { ref } from 'vue'
const count = ref(0)
</script>

<template>
  <button @click="() => {
    const newValue = count.value + 1;
    count.value = newValue;
    console.log('incremented');
  }">Increment</button>
</template>
"""

[[cases]]
name = "arrow function with multiple statements in v-for"
input = """
<script setup>
import { ref } from 'vue'
const items = ref([{ id: 1, value: 0 }])
</script>

<template>
  <div v-for="item in items" :key="item.id">
    <button @click="() => {
      item.value++;
      console.log(item.id);
    }">{{ item.value }}</button>
  </div>
</template>
"""
