//! Virtual TypeScript code generation for Vue SFC type checking.
//!
//! Generates TypeScript code from Vue SFC components that can be fed
//! to tsgo for type checking. This enables full TypeScript support
//! for template expressions, props, emits, and other Vue features.
//!
//! ## Architecture
//!
//! ```text
//! Vue SFC (.vue)
//!     │
//!     ▼
//! VirtualTsGenerator
//!     │
//!     ├─► Script Setup Context (props, emits, bindings)
//!     │
//!     ├─► Template Expressions TypeScript
//!     │
//!     └─► Source Map (Vue → TypeScript positions)
//! ```

use std::path::Path;

use vize_carton::{
    source_range::{MappingData, SourceMap, SourceMapping, SourceRange},
    CompactString,
};
use vize_relief::ast::*;
use vize_relief::BindingType;

use crate::analysis::BindingMetadata;
use crate::import_resolver::{ImportResolver, ResolvedModule};
use crate::types::TypeResolver;

/// Output of virtual TypeScript generation.
#[derive(Debug, Clone)]
pub struct VirtualTsOutput {
    /// Generated TypeScript code
    pub content: String,
    /// Source map for position mapping
    pub source_map: SourceMap,
    /// Resolved external imports
    pub resolved_imports: Vec<ResolvedImport>,
    /// Diagnostics/warnings during generation
    pub diagnostics: Vec<GenerationDiagnostic>,
}

impl Default for VirtualTsOutput {
    fn default() -> Self {
        Self {
            content: String::new(),
            source_map: SourceMap::new(),
            resolved_imports: Vec::new(),
            diagnostics: Vec::new(),
        }
    }
}

/// A resolved external import.
#[derive(Debug, Clone)]
pub struct ResolvedImport {
    /// Original import specifier
    pub specifier: CompactString,
    /// Resolved module
    pub module: ResolvedModule,
    /// Imported names
    pub names: Vec<CompactString>,
}

/// A diagnostic message from generation.
#[derive(Debug, Clone)]
pub struct GenerationDiagnostic {
    /// Message text
    pub message: CompactString,
    /// Source range (if applicable)
    pub range: Option<SourceRange>,
    /// Severity level
    pub severity: DiagnosticSeverity,
}

/// Diagnostic severity.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DiagnosticSeverity {
    /// Error - generation failed
    Error,
    /// Warning - generation succeeded with issues
    Warning,
    /// Info - informational message
    Info,
}

/// Virtual TypeScript generator.
///
/// Generates TypeScript code from Vue SFC components for type checking.
/// Supports:
/// - Script setup with defineProps/defineEmits
/// - Template expressions with proper typing
/// - External type imports resolution
pub struct VirtualTsGenerator {
    /// Type resolver for inline types
    type_resolver: TypeResolver,
    /// Import resolver for external types
    import_resolver: Option<ImportResolver>,
    /// Generated output buffer
    output: String,
    /// Source mappings
    mappings: Vec<SourceMapping>,
    /// Current output offset
    gen_offset: u32,
    /// Expression counter for unique names
    expr_counter: u32,
    /// Block offset in original SFC
    block_offset: u32,
    /// Resolved imports
    resolved_imports: Vec<ResolvedImport>,
    /// Generation diagnostics
    diagnostics: Vec<GenerationDiagnostic>,
}

impl VirtualTsGenerator {
    /// Create a new generator.
    pub fn new() -> Self {
        Self {
            type_resolver: TypeResolver::new(),
            import_resolver: None,
            output: String::with_capacity(4096),
            mappings: Vec::with_capacity(64),
            gen_offset: 0,
            expr_counter: 0,
            block_offset: 0,
            resolved_imports: Vec::new(),
            diagnostics: Vec::new(),
        }
    }

    /// Create with an import resolver.
    pub fn with_import_resolver(mut self, resolver: ImportResolver) -> Self {
        self.import_resolver = Some(resolver);
        self
    }

    /// Set the type resolver.
    pub fn with_type_resolver(mut self, resolver: TypeResolver) -> Self {
        self.type_resolver = resolver;
        self
    }

    /// Reset state for a new generation.
    fn reset(&mut self) {
        self.output.clear();
        self.mappings.clear();
        self.gen_offset = 0;
        self.expr_counter = 0;
        self.block_offset = 0;
        self.resolved_imports.clear();
        self.diagnostics.clear();
    }

    /// Generate virtual TypeScript from script setup content.
    ///
    /// This processes the script setup block and generates TypeScript
    /// that includes proper typing for defineProps, defineEmits, etc.
    pub fn generate_script_setup(
        &mut self,
        script_content: &str,
        bindings: &BindingMetadata,
        from_file: Option<&Path>,
    ) -> VirtualTsOutput {
        self.reset();

        // Header
        self.write_line("// Virtual TypeScript for Vue SFC type checking");
        self.write_line("// Generated by vize_croquis");
        self.write_line("");

        // Include original script content for type checking
        // Convert relative imports to absolute paths so they work from temp directory
        self.write_line("// Original script content");
        let processed_content = self.resolve_import_paths(script_content, from_file);
        self.write_line(&processed_content);
        self.write_line("");

        // Add $event for event handlers in template
        self.write_line("// Event handler context");
        self.write_line("declare const $event: Event;");
        self.write_line("");

        // Generate props type (for component signature)
        self.generate_props_type(bindings);

        // Generate emits type (for component signature)
        self.generate_emits_type(bindings);

        self.create_output()
    }

    /// Resolve relative import paths to absolute paths
    fn resolve_import_paths(&self, content: &str, from_file: Option<&Path>) -> String {
        let Some(file_path) = from_file else {
            return content.to_string();
        };
        let Some(parent) = file_path.parent() else {
            return content.to_string();
        };

        // Match import statements with relative paths
        let import_re = regex::Regex::new(
            r#"(import\s+(?:type\s+)?(?:\{[^}]*\}|[^{}\s]+)\s+from\s+['"])(\.[^'"]+)(['"])"#,
        );

        match import_re {
            Ok(re) => re
                .replace_all(content, |caps: &regex::Captures| {
                    let prefix = caps.get(1).map(|m| m.as_str()).unwrap_or("");
                    let rel_path = caps.get(2).map(|m| m.as_str()).unwrap_or("");
                    let suffix = caps.get(3).map(|m| m.as_str()).unwrap_or("");

                    // Resolve relative path to absolute
                    let resolved = parent.join(rel_path);
                    let abs_path = resolved
                        .canonicalize()
                        .ok()
                        .and_then(|p| p.to_str().map(String::from))
                        .unwrap_or_else(|| resolved.to_string_lossy().to_string());

                    format!("{}{}{}", prefix, abs_path, suffix)
                })
                .to_string(),
            Err(_) => content.to_string(),
        }
    }

    /// Generate virtual TypeScript from template AST.
    ///
    /// Extracts all expressions from the template and generates
    /// TypeScript that can be type-checked.
    ///
    /// `emit_context` controls whether __ctx declaration and destructuring are emitted.
    /// Set to false when merging with script output to avoid duplicates.
    pub fn generate_template(
        &mut self,
        ast: &RootNode,
        bindings: &BindingMetadata,
        block_offset: u32,
        emit_context: bool,
    ) -> VirtualTsOutput {
        self.reset();
        self.block_offset = block_offset;

        if emit_context {
            // Header
            self.write_line("// Virtual TypeScript for template type checking");
            self.write_line("// Generated by vize_croquis");
            self.write_line("");

            // Generate context type from bindings
            self.write_line("// Context from script setup");
            self.write("declare const __ctx: { ");

            let binding_entries: Vec<_> = bindings.bindings.iter().collect();
            for (i, (name, _)) in binding_entries.iter().enumerate() {
                if i > 0 {
                    self.write(", ");
                }
                // Use 'any' for all bindings to avoid false positives
                self.write(&format!("{}: any", name));
            }
            self.write_line(" };");

            // Destructure context variables for direct use in expressions
            if !binding_entries.is_empty() {
                self.write("const { ");
                for (i, (name, _)) in binding_entries.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.write(name);
                }
                self.write_line(" } = __ctx;");
            }
            self.write_line("");
        }

        // Extract and emit template expressions
        self.write_line("// Template expressions");
        self.visit_children(&ast.children);

        self.create_output()
    }

    /// Generate props type definition.
    fn generate_props_type(&mut self, bindings: &BindingMetadata) {
        self.write_line("// Props type");
        self.write("type __Props = { ");

        let props: Vec<_> = bindings
            .bindings
            .iter()
            .filter(|(_, t)| matches!(t, BindingType::Props | BindingType::PropsAliased))
            .collect();

        for (i, (name, _)) in props.iter().enumerate() {
            if i > 0 {
                self.write(", ");
            }
            self.write(&format!("{}?: any", name));
        }

        self.write_line(" };");
        self.write_line("");
    }

    /// Generate emits type definition.
    fn generate_emits_type(&mut self, _bindings: &BindingMetadata) {
        self.write_line("// Emits type");
        self.write_line("type __Emits = {};");
        self.write_line("");
    }
    /// Visit template children.
    fn visit_children(&mut self, children: &[TemplateChildNode]) {
        for child in children {
            self.visit_child(child);
        }
    }

    /// Visit a single template child.
    fn visit_child(&mut self, node: &TemplateChildNode) {
        match node {
            TemplateChildNode::Element(el) => self.visit_element(el),
            TemplateChildNode::Interpolation(interp) => self.visit_interpolation(interp),
            TemplateChildNode::If(if_node) => self.visit_if(if_node),
            TemplateChildNode::For(for_node) => self.visit_for(for_node),
            TemplateChildNode::IfBranch(branch) => {
                if let Some(ref cond) = branch.condition {
                    self.emit_expression(cond, "v-if");
                }
                self.visit_children(&branch.children);
            }
            _ => {}
        }
    }

    /// Visit an element node.
    fn visit_element(&mut self, element: &ElementNode) {
        // Check if this element has a v-for directive
        let v_for_exp = element.props.iter().find_map(|prop| {
            if let PropNode::Directive(dir) = prop {
                if dir.name == "for" {
                    return dir.exp.as_ref();
                }
            }
            None
        });

        // If v-for directive exists, handle it with proper scoping
        if let Some(exp) = v_for_exp {
            self.emit_v_for_scope(exp, |this| {
                // Process other directives (not v-for)
                for prop in &element.props {
                    if let PropNode::Directive(dir) = prop {
                        if dir.name != "for" {
                            this.visit_directive(dir);
                        }
                    }
                }
                // Process children
                this.visit_children(&element.children);
            });
        } else {
            // No v-for - process normally
            for prop in &element.props {
                if let PropNode::Directive(dir) = prop {
                    self.visit_directive(dir);
                }
            }
            self.visit_children(&element.children);
        }
    }

    /// Emit v-for scope with loop variables
    fn emit_v_for_scope<F>(&mut self, exp: &ExpressionNode, body: F)
    where
        F: FnOnce(&mut Self),
    {
        let content = match exp {
            ExpressionNode::Simple(s) => s.content.as_str(),
            ExpressionNode::Compound(c) => c.loc.source.as_str(),
        };

        // Parse v-for expression: "item in items" or "(item, index) in items"
        if let Some(in_pos) = content.find(" in ").or_else(|| content.find(" of ")) {
            let left = &content[..in_pos];
            let right = &content[in_pos + 4..];

            self.write_line("// v-for scope");
            self.write_line("{");

            // Extract and declare loop variables
            let vars_part = left.trim();
            let vars_part = vars_part.trim_start_matches('(').trim_end_matches(')');
            for var in vars_part.split(',') {
                let var = var.trim();
                if !var.is_empty()
                    && var
                        .chars()
                        .all(|c| c.is_alphanumeric() || c == '_' || c == '$')
                {
                    self.write_line(&format!("  let {}: any;", var));
                }
            }

            // Emit the source expression (right side)
            let source = right.trim();
            let var_name = format!("__expr_{}", self.expr_counter);
            self.expr_counter += 1;
            self.write_line(&format!("  const {} = {};", var_name, source));

            // Execute body in this scope
            body(self);

            self.write_line("}");
        } else {
            // Fallback: just emit the expression and run body
            self.emit_expression(exp, "v-for");
            body(self);
        }
    }

    /// Visit a directive.
    fn visit_directive(&mut self, directive: &DirectiveNode) {
        if let Some(ref exp) = directive.exp {
            self.emit_expression(exp, &directive.name);
        }
    }

    /// Visit an interpolation.
    fn visit_interpolation(&mut self, interp: &InterpolationNode) {
        self.emit_expression(&interp.content, "interpolation");
    }

    /// Visit an if node.
    fn visit_if(&mut self, if_node: &IfNode) {
        for branch in &if_node.branches {
            if let Some(ref cond) = branch.condition {
                self.emit_expression(cond, "v-if");
            }
            self.visit_children(&branch.children);
        }
    }

    /// Visit a for node.
    fn visit_for(&mut self, for_node: &ForNode) {
        // Use parse_result which contains the properly parsed v-for components
        let parse_result = &for_node.parse_result;

        self.write_line("// v-for scope");
        self.write_line("{");

        // Helper to extract variable name from expression
        fn extract_var_name(expr: &ExpressionNode) -> Option<String> {
            match expr {
                ExpressionNode::Simple(simple) => {
                    let name = simple.content.trim();
                    if !name.is_empty()
                        && name
                            .chars()
                            .all(|c| c.is_alphanumeric() || c == '_' || c == '$')
                    {
                        Some(name.to_string())
                    } else {
                        None
                    }
                }
                ExpressionNode::Compound(compound) => {
                    // For compound expressions, try to get the first child
                    use vize_relief::ast::CompoundExpressionChild;
                    if let Some(CompoundExpressionChild::Simple(simple)) = compound.children.first()
                    {
                        let name = simple.content.trim();
                        if !name.is_empty()
                            && name
                                .chars()
                                .all(|c| c.is_alphanumeric() || c == '_' || c == '$')
                        {
                            return Some(name.to_string());
                        }
                    }
                    None
                }
            }
        }

        // Declare loop variables from parse_result
        if let Some(ref value) = parse_result.value {
            if let Some(var_name) = extract_var_name(value) {
                self.write_line(&format!("  let {}: any;", var_name));
            }
        }
        if let Some(ref key) = parse_result.key {
            if let Some(var_name) = extract_var_name(key) {
                self.write_line(&format!("  let {}: any;", var_name));
            }
        }
        if let Some(ref index) = parse_result.index {
            if let Some(var_name) = extract_var_name(index) {
                self.write_line(&format!("  let {}: any;", var_name));
            }
        }

        // Also check the direct aliases on ForNode (might be populated in some cases)
        if let Some(ref value_alias) = for_node.value_alias {
            if let Some(var_name) = extract_var_name(value_alias) {
                self.write_line(&format!("  let {}: any;", var_name));
            }
        }
        if let Some(ref key_alias) = for_node.key_alias {
            if let Some(var_name) = extract_var_name(key_alias) {
                self.write_line(&format!("  let {}: any;", var_name));
            }
        }
        if let Some(ref index_alias) = for_node.object_index_alias {
            if let Some(var_name) = extract_var_name(index_alias) {
                self.write_line(&format!("  let {}: any;", var_name));
            }
        }

        // Emit the source expression (the collection being iterated)
        let source_expr = &parse_result.source;
        match source_expr {
            ExpressionNode::Simple(simple) => {
                if !simple.content.is_empty() {
                    let var_name = format!("__expr_{}", self.expr_counter);
                    self.expr_counter += 1;
                    self.write_line(&format!("  const {} = {};", var_name, simple.content));
                }
            }
            ExpressionNode::Compound(_) => {
                // Fallback for compound
                self.emit_expression(source_expr, "v-for source");
            }
        }

        // Visit children in this scope
        self.visit_children(&for_node.children);

        self.write_line("}");
    }

    /// Emit a TypeScript expression with source mapping.
    fn emit_expression(&mut self, expr: &ExpressionNode, context: &str) {
        match expr {
            ExpressionNode::Simple(simple) => {
                if simple.content.is_empty() {
                    return;
                }

                let var_name = format!("__expr_{}", self.expr_counter);
                self.expr_counter += 1;

                // Generate: const __expr_N = expr;
                // Context variables are available via destructuring at the top
                let prefix = format!("const {} = ", var_name);
                let line = format!("{}{};\n", prefix, simple.content);

                // Calculate positions for mapping
                let expr_start = self.gen_offset + prefix.len() as u32;
                let expr_end = expr_start + simple.content.len() as u32;

                let source_start = simple.loc.start.offset + self.block_offset;
                let source_end = simple.loc.end.offset + self.block_offset;

                // Create mapping
                self.mappings.push(SourceMapping::with_data(
                    SourceRange::new(source_start, source_end),
                    SourceRange::new(expr_start, expr_end),
                    MappingData::Expression {
                        text: simple.content.to_string(),
                    },
                ));

                self.write(&line);
            }
            ExpressionNode::Compound(_) => {
                // For compound expressions, emit a placeholder
                let var_name = format!("__expr_{}", self.expr_counter);
                self.expr_counter += 1;
                let line = format!(
                    "const {} = void 0 as any; // {} compound\n",
                    var_name, context
                );
                self.write(&line);
            }
        }
    }

    /// Create the output from current state.
    fn create_output(&mut self) -> VirtualTsOutput {
        let mut source_map = SourceMap::from_mappings(std::mem::take(&mut self.mappings));
        source_map.set_block_offset(self.block_offset);

        VirtualTsOutput {
            content: std::mem::take(&mut self.output),
            source_map,
            resolved_imports: std::mem::take(&mut self.resolved_imports),
            diagnostics: std::mem::take(&mut self.diagnostics),
        }
    }

    /// Write a string to output.
    fn write(&mut self, s: &str) {
        self.output.push_str(s);
        self.gen_offset += s.len() as u32;
    }

    /// Write a line to output.
    fn write_line(&mut self, s: &str) {
        self.output.push_str(s);
        self.output.push('\n');
        self.gen_offset += s.len() as u32 + 1;
    }
}

impl Default for VirtualTsGenerator {
    fn default() -> Self {
        Self::new()
    }
}

/// Convenience function to generate virtual TypeScript from a full SFC.
pub fn generate_virtual_ts(
    script_content: Option<&str>,
    template_ast: Option<&RootNode>,
    bindings: &BindingMetadata,
    import_resolver: Option<ImportResolver>,
    from_file: Option<&Path>,
    template_offset: u32,
) -> VirtualTsOutput {
    let mut gen = VirtualTsGenerator::new();
    if let Some(resolver) = import_resolver {
        gen = gen.with_import_resolver(resolver);
    }

    // Generate script output first if present
    let script_output = script_content.map(|s| gen.generate_script_setup(s, bindings, from_file));
    let has_script = script_output.is_some();

    // Generate template output
    // emit_context is false when script exists to avoid duplicate declarations
    let template_output =
        template_ast.map(|ast| gen.generate_template(ast, bindings, template_offset, !has_script));

    // Combine outputs
    match (script_output, template_output) {
        (Some(mut script), Some(template)) => {
            // Merge template content into script
            script.content.push('\n');
            script.content.push_str(&template.content);

            // Adjust template mappings and merge
            let script_len = script.content.len() as u32;
            for mut mapping in template.source_map.mappings().iter().cloned() {
                mapping.generated.start += script_len;
                mapping.generated.end += script_len;
                script.source_map.add(mapping);
            }

            script.diagnostics.extend(template.diagnostics);
            script
        }
        (Some(script), None) => script,
        (None, Some(template)) => template,
        (None, None) => VirtualTsOutput::default(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_script_setup() {
        let script = r#"
const msg = ref('Hello');
const count = ref(0);
"#;
        let mut bindings = BindingMetadata::default();
        bindings.add("msg", BindingType::SetupRef);
        bindings.add("count", BindingType::SetupRef);

        let mut gen = VirtualTsGenerator::new();
        let output = gen.generate_script_setup(script, &bindings, None);

        // Script content should be included directly for type checking
        assert!(output.content.contains("msg"));
        assert!(output.content.contains("count"));
        assert!(output.content.contains("Original script content"));
    }

    #[test]
    fn test_generate_template() {
        let source = r#"<div>{{ message }}</div>"#;
        let allocator = vize_carton::Bump::new();
        let (ast, _) = vize_armature::parse(&allocator, source);

        let mut bindings = BindingMetadata::default();
        bindings.add("message", BindingType::SetupRef);

        let mut gen = VirtualTsGenerator::new();
        let output = gen.generate_template(&ast, &bindings, 0, true);

        assert!(output.content.contains("__ctx"));
        assert!(output.content.contains("message"));
        assert!(!output.source_map.is_empty());
    }
}
