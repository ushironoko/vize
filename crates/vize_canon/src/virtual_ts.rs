//! Virtual TypeScript generation for Vue SFC type checking.
//!
//! This module generates TypeScript code that represents a Vue SFC's
//! runtime behavior, enabling type checking of template expressions
//! and script setup bindings.

use vize_croquis::{AnalysisSummary, BindingType};

/// Vue runtime type declarations for type checking.
/// Minimal declarations to avoid conflicts with user imports.
pub const VUE_RUNTIME_TYPES: &str = r#"// Vue SFC compiler macros (available globally in <script setup>)
declare function defineProps<T>(): T;
declare function defineEmits<T>(): T;
declare function defineExpose<T>(exposed?: T): void;
declare function defineModel<T>(name?: string, options?: any): any;
declare function withDefaults<T, D>(props: T, defaults: D): T & D;

// Vue instance context
declare const $attrs: Record<string, unknown>;
declare const $slots: Record<string, (...args: any[]) => any>;
declare const $refs: Record<string, any>;
declare const $emit: (...args: any[]) => void;
declare const $event: Event;"#;

/// Generate virtual TypeScript from Vue SFC analysis.
///
/// The generated TypeScript includes:
/// - Vue runtime type imports
/// - Vue global instance declarations ($attrs, $slots, $refs, etc.)
/// - The original script content
/// - Exported type definitions (Props, Emits, Slots)
/// - Template type verification function
/// - Source map markers for position mapping
pub fn generate_virtual_ts(
    summary: &AnalysisSummary,
    script_content: Option<&str>,
    template_ast: Option<&vize_relief::ast::RootNode<'_>>,
    template_offset: u32,
) -> String {
    let mut ts = String::new();

    // Header
    ts.push_str("// ============================================\n");
    ts.push_str("// Virtual TypeScript for Vue SFC Type Checking\n");
    ts.push_str("// Generated by vize\n");
    ts.push_str("// ============================================\n\n");

    // Vue Runtime Type Declarations
    ts.push_str("// ========== Vue Runtime Types ==========\n");
    ts.push_str(VUE_RUNTIME_TYPES);
    ts.push_str("\n\n");

    ts.push('\n');

    // Setup Function (supports generics)
    // TODO: Extract generic type parameter from <script setup generic="T">
    let has_generic = false; // Will be enabled when croquis supports generic tracking

    // Original Script
    // Note: .vue imports will cause TS2307 errors which are filtered in check command
    if let Some(script) = script_content {
        ts.push_str("// ========== Script Setup ==========\n");
        let script_gen_start = ts.len();
        ts.push_str(script);
        let script_gen_end = ts.len();
        ts.push('\n');
        // Source map marker
        ts.push_str(&format!(
            "// @vize-map: {}:{} -> 0:{}\n\n",
            script_gen_start,
            script_gen_end,
            script.len()
        ));
    }

    // Props declarations for template access
    let props = summary.macros.props();
    let has_props = !props.is_empty();

    // Get defineProps type args for proper typing
    let define_props_type_args = summary
        .macros
        .define_props()
        .and_then(|m| m.type_args.as_ref());

    // Check if Props is already defined in user code (interface Props or type Props)
    let props_already_defined = summary
        .type_exports
        .iter()
        .any(|te| te.name.as_str() == "Props");

    // Check if Emits is already defined in user code
    let emits_already_defined = summary
        .type_exports
        .iter()
        .any(|te| te.name.as_str() == "Emits");

    // Exported Types (define Props type first so it can be referenced)
    ts.push_str("// ========== Exported Types ==========\n");

    // Props type - skip if user already defined it
    if props_already_defined {
        // User defined Props, no need to re-export
    } else if let Some(type_args) = define_props_type_args {
        // Remove angle brackets from type_args (e.g., "<{ foo: string }>" -> "{ foo: string }")
        let inner_type = type_args
            .strip_prefix('<')
            .and_then(|s| s.strip_suffix('>'))
            .unwrap_or(type_args.as_str());
        // Check if inner_type is a simple identifier that matches an existing type
        let is_simple_reference = inner_type.chars().all(|c| c.is_alphanumeric() || c == '_');
        if is_simple_reference
            && summary
                .type_exports
                .iter()
                .any(|te| te.name.as_str() == inner_type)
        {
            // Type arg references an existing type, no need to re-export
        } else {
            ts.push_str(&format!("export type Props = {};\n", inner_type));
        }
    } else if has_props {
        ts.push_str("export type Props = {\n");
        for prop in props {
            let prop_type = prop.prop_type.as_deref().unwrap_or("unknown");
            let optional = if prop.required { "" } else { "?" };
            ts.push_str(&format!("  {}{}: {};\n", prop.name, optional, prop_type));
        }
        ts.push_str("};\n");
    } else {
        ts.push_str("export type Props = {};\n");
    }

    // Props declarations for template access - use actual types from Props
    if has_props || define_props_type_args.is_some() {
        ts.push_str("\n// ========== Props Declarations ==========\n");
        ts.push_str("// Props are auto-unwrapped in template\n");
        for prop in props {
            // Use indexed access Props['propName'] for proper typing
            let prop_type = prop
                .prop_type
                .as_deref()
                .map(String::from)
                .unwrap_or_else(|| format!("Props['{}']", prop.name));
            ts.push_str(&format!("declare const {}: {};\n", prop.name, prop_type));
        }
        // Define __props with full Props type
        ts.push_str("declare const __props: Props;\n");
    }

    // Emits type - skip if user already defined it
    let emits = summary.macros.emits();
    if emits_already_defined {
        // User defined Emits, no need to re-export
    } else {
        // Just export empty Emits since we can't infer the type properly
        ts.push_str("export type Emits = {};\n");
    }

    // Slots type (TODO: add slots tracking to MacroTracker)
    ts.push_str("export type Slots = {};\n");

    ts.push('\n');

    // Macro Information
    ts.push_str("// ========== Macro Information ==========\n");
    let macros = &summary.macros;

    // defineProps details
    if !props.is_empty() {
        ts.push_str("// defineProps:\n");
        for prop in props {
            ts.push_str(&format!("//   - {}\n", prop.name));
        }
    }

    // defineEmits details
    if !emits.is_empty() {
        ts.push_str("// defineEmits:\n");
        for emit in emits {
            ts.push_str(&format!("//   - {}\n", emit.name));
        }
    }

    // defineModel
    let models = macros.models();
    if !models.is_empty() {
        ts.push_str("// defineModel:\n");
        for model in models {
            ts.push_str(&format!("//   - {}\n", model.name));
        }
    }

    ts.push('\n');

    // Binding Type Inference
    ts.push_str("// ========== Inferred Bindings ==========\n");
    for (name, binding_type) in summary.bindings.iter() {
        let type_hint = match binding_type {
            BindingType::SetupRef => format!("// {}: Ref<inferred>", name),
            BindingType::SetupConst => format!("// {}: inferred const", name),
            BindingType::SetupLet => format!("// {}: inferred let", name),
            BindingType::SetupReactiveConst => format!("// {}: reactive<inferred>", name),
            BindingType::SetupMaybeRef => format!("// {}: MaybeRef<inferred>", name),
            BindingType::Props => format!("// {}: from props", name),
            BindingType::PropsAliased => format!("// {}: aliased from props", name),
            _ => format!("// {}: {:?}", name, binding_type),
        };
        ts.push_str(&format!("{}\n", type_hint));
    }
    ts.push('\n');

    // Template Type Verification
    if template_ast.is_some() {
        ts.push_str("// ========== Template Type Verification ==========\n");
        ts.push_str("// @ts-ignore - Verification function for type checking template bindings\n");
        ts.push_str("function __verifyTemplateTypes() {\n");

        // Verify all bindings are accessible with proper types
        // Skip Props/PropsAliased as they are properties of the props object, not standalone variables
        for (name, binding_type) in summary.bindings.iter() {
            // Props bindings are accessed via props.name, not as standalone variables
            if matches!(binding_type, BindingType::Props | BindingType::PropsAliased) {
                continue;
            }
            let access = match binding_type {
                BindingType::SetupRef | BindingType::Data => {
                    format!("  const __{}_value = {}.value;", name, name)
                }
                BindingType::SetupMaybeRef => {
                    format!("  const __{}_value = unref({});", name, name)
                }
                _ => format!("  const __{}_value = {};", name, name),
            };
            ts.push_str(&format!("{}\n", access));
        }

        // Check for undefined references with source mapping
        if !summary.undefined_refs.is_empty() {
            ts.push_str("\n  // ERROR: Undefined references detected\n");
            for undef in &summary.undefined_refs {
                let src_start = template_offset + undef.offset;
                let src_end = src_start + undef.name.len() as u32;

                ts.push_str(&format!(
                    "  // @ts-expect-error '{}' is not defined ({})\n",
                    undef.name, undef.context
                ));

                let gen_start = ts.len();
                let expr_code = format!("  const __undef_{} = {};\n", undef.name, undef.name);
                let name_offset = expr_code.find(undef.name.as_str()).unwrap_or(0);
                let gen_name_start = gen_start + name_offset;
                let gen_name_end = gen_name_start + undef.name.len();

                ts.push_str(&expr_code);
                ts.push_str(&format!(
                    "  // @vize-map: {}:{} -> {}:{}\n",
                    gen_name_start, gen_name_end, src_start, src_end
                ));
            }
        }

        ts.push_str("}\n\n");

        // Event Handler Type Context
        ts.push_str("// ========== Event Handler Context ==========\n");
        ts.push_str("// $event is available in event handlers\n");
        ts.push_str("function __eventHandlerContext<T>(handler: (e: T) => void): void {\n");
        ts.push_str("  // Event handler context where $event is typed as T\n");
        ts.push_str("}\n");
    }

    // Close generic function wrapper if present
    if has_generic {
        ts.push_str("\n} // End of __VizeSetup\n");
    }

    // Default export for Vue SFC component (required for imports to work)
    ts.push_str("\n// ========== Default Export ==========\n");
    ts.push_str("// Vue SFC default export for component imports\n");
    ts.push_str("declare const __vize_component__: {\n");
    ts.push_str("  props: Props;\n");
    ts.push_str("  emits: Emits;\n");
    ts.push_str("  slots: Slots;\n");
    ts.push_str("};\n");
    ts.push_str("export default __vize_component__;\n");

    ts
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vue_runtime_types_contains_declarations() {
        assert!(VUE_RUNTIME_TYPES.contains("declare function defineProps"));
        assert!(VUE_RUNTIME_TYPES.contains("declare function defineEmits"));
        assert!(VUE_RUNTIME_TYPES.contains("$attrs"));
        assert!(VUE_RUNTIME_TYPES.contains("$slots"));
    }
}
