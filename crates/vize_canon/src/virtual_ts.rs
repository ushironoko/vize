//! Virtual TypeScript generation for Vue SFC type checking.
//!
//! This module generates TypeScript code that represents a Vue SFC's
//! runtime behavior, enabling type checking of template expressions
//! and script setup bindings.

use vize_croquis::{AnalysisSummary, BindingType};

/// Vue runtime type declarations for type checking.
/// Uses imports from 'vue' so Monaco/TypeScript can resolve actual Vue types.
pub const VUE_RUNTIME_TYPES: &str = r#"// Import Vue types (resolved by Monaco TypeScript)
import type {
  Ref,
  ComputedRef,
  UnwrapRef,
  Reactive,
  ShallowRef,
  WritableComputedRef,
} from 'vue';

import {
  ref,
  reactive,
  computed,
  watch,
  watchEffect,
  unref,
  toRef,
  toRefs,
  shallowRef,
  triggerRef,
  customRef,
  readonly,
  onMounted,
  onUnmounted,
  onBeforeMount,
  onBeforeUnmount,
  onUpdated,
  onBeforeUpdate,
  onActivated,
  onDeactivated,
  onErrorCaptured,
  nextTick,
  getCurrentInstance,
  inject,
  provide,
} from 'vue';

// Re-export MaybeRef type alias
type MaybeRef<T> = T | Ref<T>;"#;

/// Generate virtual TypeScript from Vue SFC analysis.
///
/// The generated TypeScript includes:
/// - Vue runtime type imports
/// - Vue global instance declarations ($attrs, $slots, $refs, etc.)
/// - The original script content
/// - Exported type definitions (Props, Emits, Slots)
/// - Template type verification function
/// - Source map markers for position mapping
pub fn generate_virtual_ts(
    summary: &AnalysisSummary,
    script_content: Option<&str>,
    template_ast: Option<&vize_relief::ast::RootNode<'_>>,
    template_offset: u32,
) -> String {
    let mut ts = String::new();

    // Header
    ts.push_str("// ============================================\n");
    ts.push_str("// Virtual TypeScript for Vue SFC Type Checking\n");
    ts.push_str("// Generated by vize\n");
    ts.push_str("// ============================================\n\n");

    // Vue Runtime Type Declarations
    ts.push_str("// ========== Vue Runtime Types ==========\n");
    ts.push_str(VUE_RUNTIME_TYPES);
    ts.push_str("\n\n");

    // Vue Global Instance Context
    ts.push_str("// ========== Vue Instance Context ==========\n");
    ts.push_str("declare const $attrs: Record<string, unknown>;\n");
    ts.push_str("declare const $slots: Record<string, (...args: any[]) => any>;\n");
    ts.push_str("declare const $refs: Record<string, any>;\n");
    ts.push_str("declare const $el: HTMLElement | undefined;\n");
    ts.push_str("declare const $parent: any;\n");
    ts.push_str("declare const $root: any;\n");
    ts.push_str("declare const $emit: (...args: any[]) => void;\n");
    ts.push_str("declare const $forceUpdate: () => void;\n");
    ts.push_str("declare const $nextTick: (callback?: () => void) => Promise<void>;\n");
    ts.push_str("declare const $event: Event;\n\n");

    // Setup Function (supports generics)
    // TODO: Extract generic type parameter from <script setup generic="T">
    let has_generic = false; // Will be enabled when croquis supports generic tracking

    // Original Script
    if let Some(script) = script_content {
        ts.push_str("// ========== Script Setup ==========\n");
        let script_gen_start = ts.len();
        ts.push_str(script);
        let script_gen_end = ts.len();
        ts.push('\n');
        // Source map marker
        ts.push_str(&format!(
            "// @vize-map: {}:{} -> 0:{}\n\n",
            script_gen_start,
            script_gen_end,
            script.len()
        ));
    }

    // Exported Types
    ts.push_str("// ========== Exported Types ==========\n");

    // Props type
    let props = summary.macros.props();
    if !props.is_empty() {
        ts.push_str(
            "export type Props = typeof __props extends undefined ? {} : typeof __props;\n",
        );
    } else {
        ts.push_str("export type Props = {};\n");
    }

    // Emits type
    let emits = summary.macros.emits();
    if !emits.is_empty() {
        ts.push_str("export type Emits = typeof __emit extends undefined ? {} : typeof __emit;\n");
    } else {
        ts.push_str("export type Emits = {};\n");
    }

    // Slots type (TODO: add slots tracking to MacroTracker)
    ts.push_str("export type Slots = {};\n");

    ts.push('\n');

    // Macro Information
    ts.push_str("// ========== Macro Information ==========\n");
    let macros = &summary.macros;

    // defineProps details
    if !props.is_empty() {
        ts.push_str("// defineProps:\n");
        for prop in props {
            ts.push_str(&format!("//   - {}\n", prop.name));
        }
    }

    // defineEmits details
    if !emits.is_empty() {
        ts.push_str("// defineEmits:\n");
        for emit in emits {
            ts.push_str(&format!("//   - {}\n", emit.name));
        }
    }

    // defineModel
    let models = macros.models();
    if !models.is_empty() {
        ts.push_str("// defineModel:\n");
        for model in models {
            ts.push_str(&format!("//   - {}\n", model.name));
        }
    }

    ts.push('\n');

    // Binding Type Inference
    ts.push_str("// ========== Inferred Bindings ==========\n");
    for (name, binding_type) in summary.bindings.iter() {
        let type_hint = match binding_type {
            BindingType::SetupRef => format!("// {}: Ref<inferred>", name),
            BindingType::SetupConst => format!("// {}: inferred const", name),
            BindingType::SetupLet => format!("// {}: inferred let", name),
            BindingType::SetupReactiveConst => format!("// {}: reactive<inferred>", name),
            BindingType::SetupMaybeRef => format!("// {}: MaybeRef<inferred>", name),
            BindingType::Props => format!("// {}: from props", name),
            BindingType::PropsAliased => format!("// {}: aliased from props", name),
            _ => format!("// {}: {:?}", name, binding_type),
        };
        ts.push_str(&format!("{}\n", type_hint));
    }
    ts.push('\n');

    // Template Type Verification
    if template_ast.is_some() {
        ts.push_str("// ========== Template Type Verification ==========\n");
        ts.push_str("function __verifyTemplateTypes() {\n");

        // Verify all bindings are accessible with proper types
        // Skip Props/PropsAliased as they are properties of the props object, not standalone variables
        for (name, binding_type) in summary.bindings.iter() {
            // Props bindings are accessed via props.name, not as standalone variables
            if matches!(binding_type, BindingType::Props | BindingType::PropsAliased) {
                continue;
            }
            let access = match binding_type {
                BindingType::SetupRef | BindingType::Data => {
                    format!("  const __{}_value = {}.value;", name, name)
                }
                BindingType::SetupMaybeRef => {
                    format!("  const __{}_value = unref({});", name, name)
                }
                _ => format!("  const __{}_value = {};", name, name),
            };
            ts.push_str(&format!("{}\n", access));
        }

        // Check for undefined references with source mapping
        if !summary.undefined_refs.is_empty() {
            ts.push_str("\n  // ERROR: Undefined references detected\n");
            for undef in &summary.undefined_refs {
                let src_start = template_offset + undef.offset;
                let src_end = src_start + undef.name.len() as u32;

                ts.push_str(&format!(
                    "  // @ts-expect-error '{}' is not defined ({})\n",
                    undef.name, undef.context
                ));

                let gen_start = ts.len();
                let expr_code = format!("  const __undef_{} = {};\n", undef.name, undef.name);
                let name_offset = expr_code.find(undef.name.as_str()).unwrap_or(0);
                let gen_name_start = gen_start + name_offset;
                let gen_name_end = gen_name_start + undef.name.len();

                ts.push_str(&expr_code);
                ts.push_str(&format!(
                    "  // @vize-map: {}:{} -> {}:{}\n",
                    gen_name_start, gen_name_end, src_start, src_end
                ));
            }
        }

        ts.push_str("}\n\n");

        // Event Handler Type Context
        ts.push_str("// ========== Event Handler Context ==========\n");
        ts.push_str("// $event is available in event handlers\n");
        ts.push_str("function __eventHandlerContext<T>(handler: (e: T) => void): void {\n");
        ts.push_str("  // Event handler context where $event is typed as T\n");
        ts.push_str("}\n");
    }

    // Close generic function wrapper if present
    if has_generic {
        ts.push_str("\n} // End of __VizeSetup\n");
    }

    ts
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vue_runtime_types_contains_imports() {
        assert!(VUE_RUNTIME_TYPES.contains("import type"));
        assert!(VUE_RUNTIME_TYPES.contains("from 'vue'"));
        assert!(VUE_RUNTIME_TYPES.contains("Ref"));
        assert!(VUE_RUNTIME_TYPES.contains("computed"));
    }
}
